<!DOCTYPE html>

<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">

		<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Search | 文王之殇 –前端加油站</title>
<meta name="generator" content="Jekyll v3.8.4" />
<meta property="og:title" content="Search" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Product documentation template for Jekyll." />
<meta property="og:description" content="Product documentation template for Jekyll." />
<link rel="canonical" href="http://localhost:4000/search/" />
<meta property="og:url" content="http://localhost:4000/search/" />
<meta property="og:site_name" content="文王之殇 –前端加油站" />
<script type="application/ld+json">
{"url":"http://localhost:4000/search/","headline":"Search","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"http://localhost:4000/siteicon.png"}},"description":"Product documentation template for Jekyll.","@type":"WebPage","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

		<link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="文王之殇 --前端加油站" />

		<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Merriweather:400,400italic,700,700italic|Open+Sans:400,400italic,600,600italic,700,700italic|Inconsolata:400,700">
		<link rel="stylesheet" href="/css/main.css">
		<link rel="apple-touch-icon" href="/apple-touch-icon.png">
		<link rel="icon" type="image/png" href="/touch-icon.png" sizes="192x192">
		<link rel="icon" type="image/png" href="/images/favicon.png">

		
	</head>

	<body>
		<div class="righttips" id="backtop">
			返回
		</div>
		<header>
			<div class="left_head">	
				<h1>
					<a href="/"><img src="/images/emblem.svg" width="40" height="40" alt="文王之殇 --前端加油站 logo"></a>
					文王之殇 --前端加油站
					<button type="button" class="open-nav" id="open-nav"></button>
				</h1>

				<form action="/search/" method="get">
					<input type="text" name="q" id="search-input" placeholder="Search" autofocus>
					<input type="submit" value="Search" style="display: none;">
				</form>

			</div>
		
			<nav class="full-navigation">
				<ul>
					<li class="nav-item top-level ">
						
						<a href="/">欢迎</a>
					</li>
				</ul>

				<ul>
					
					
						<li class="nav-item top-level ">
							
							<a href="/A_Css/vetically/">CSS</a>
							<ul>
								
									<li class="nav-item "><a href="/A_Css/vetically/">垂直居中</a></li>
								
									<li class="nav-item "><a href="/A_Css/box/">盒模型</a></li>
								
							</ul>
						</li>
					
						<li class="nav-item top-level ">
							
							<a href="/B_Js/AMD_CMD/">JS 基础及概念</a>
							<ul>
								
									<li class="nav-item "><a href="/B_Js/AMD_CMD/">AMD、CMD、Common.js和ES6的异同</a></li>
								
									<li class="nav-item "><a href="/B_Js/es6_export/">export、export default 和 module.export的异同</a></li>
								
							</ul>
						</li>
					
						<li class="nav-item top-level ">
							
							<a href="/B_Js/js_curry/">JS</a>
							<ul>
								
									<li class="nav-item "><a href="/B_Js/js_curry/">函数柯里化</a></li>
								
									<li class="nav-item "><a href="/B_Js/js_eventloop/">js 事件执行机制</a></li>
								
							</ul>
						</li>
					
						<li class="nav-item top-level ">
							
							<a href="/C_Vue/vue_1/">Vue</a>
							<ul>
								
									<li class="nav-item "><a href="/C_Vue/vue_1/">Vue2 迁移到 Vue3 都有哪些变化</a></li>
								
									<li class="nav-item "><a href="/C_Vue/vue_2/">Vue3 源码 (3.2)</a></li>
								
							</ul>
						</li>
					
						<li class="nav-item top-level ">
							
							<a href="/D_Vite/vite_1/">Vite</a>
							<ul>
								
									<li class="nav-item "><a href="/D_Vite/vite_1/">Vite 基础</a></li>
								
									<li class="nav-item "><a href="/D_Vite/vite_2/">Vite 的构建工具</a></li>
								
							</ul>
						</li>
					
						<li class="nav-item top-level ">
							
							<a href="/D_Webpack/webpack_1/">Webpack</a>
							<ul>
								
									<li class="nav-item "><a href="/D_Webpack/webpack_1/">Webpack 基础和进阶</a></li>
								
									<li class="nav-item "><a href="/D_Webpack/webpack_2/">Webpack 和 Vite 的比较</a></li>
								
									<li class="nav-item "><a href="/D_Webpack/webpack_3/">前端如何利用Webpack进行代码分析和优化</a></li>
								
							</ul>
						</li>
					
						<li class="nav-item top-level ">
							
							<a href="/E_Node/node_1/">Node</a>
							<ul>
								
									<li class="nav-item "><a href="/E_Node/node_1/">Express的基础</a></li>
								
									<li class="nav-item "><a href="/E_Node/node_2/">Koa 基础</a></li>
								
							</ul>
						</li>
					
						<li class="nav-item top-level ">
							
							<a href="/F_MiniProgram/mini_1/">小程序</a>
							<ul>
								
									<li class="nav-item "><a href="/F_MiniProgram/mini_1/">小程序渲染机制 --- 以微信小程序为例</a></li>
								
									<li class="nav-item "><a href="/F_MiniProgram/min_2/">小程序开发步骤讲解</a></li>
								
							</ul>
						</li>
					
						<li class="nav-item top-level ">
							
							<a href="/G_Angular/angular_1/">Angular</a>
							<ul>
								
									<li class="nav-item "><a href="/G_Angular/angular_1/">浅析angular</a></li>
								
							</ul>
						</li>
					
						<li class="nav-item top-level ">
							
							<a href="/K_React/react_1/">React</a>
							<ul>
								
									<li class="nav-item "><a href="/K_React/react_1/">React基础</a></li>
								
							</ul>
						</li>
					
						<li class="nav-item top-level ">
							
							<a href="/L_Basic/web_1/">前端杂谈</a>
							<ul>
								
									<li class="nav-item "><a href="/L_Basic/web_1/">浏览器的渲染机制</a></li>
								
									<li class="nav-item "><a href="/L_Basic/web_2/">前端部署的发展历程</a></li>
								
									<li class="nav-item "><a href="/L_Basic/web_3/">浏览器缓存机制</a></li>
								
									<li class="nav-item "><a href="/L_Basic/web_4/">xhr 和 fetch请求方式的比较</a></li>
								
									<li class="nav-item "><a href="/L_Basic/web_5/">输入一个url发生了什么</a></li>
								
									<li class="nav-item "><a href="/L_Basic/web_6/">http 演进</a></li>
								
									<li class="nav-item "><a href="/L_Basic/web_7/">前端大厦的基石 --- AST</a></li>
								
									<li class="nav-item "><a href="/L_Basic/web_8/">浅谈前端优化的方向</a></li>
								
									<li class="nav-item "><a href="/L_Basic/web_9/">浏览器内存泄漏</a></li>
								
									<li class="nav-item "><a href="/L_Basic/web_10/">浏览器储存（cookie、localStorage、sessionStorage和IndexDB）</a></li>
								
							</ul>
						</li>
					
						<li class="nav-item top-level ">
							
							<a href="/M_Program/program_1/">项目</a>
							<ul>
								
									<li class="nav-item "><a href="/M_Program/program_1/">数据可视化项目</a></li>
								
									<li class="nav-item "><a href="/M_Program/program_2/">新零售会员通 -- 天猫 有赞 微信会员渠道打通项目</a></li>
								
									<li class="nav-item "><a href="/M_Program/program_3/">温顾知新</a></li>
								
							</ul>
						</li>
					
						<li class="nav-item top-level ">
							
							<a href="/N_math/math_1/">算法</a>
							<ul>
								
									<li class="nav-item "><a href="/N_math/math_1/">动态规划</a></li>
								
							</ul>
						</li>
					
				</ul>

				<ul>
					<li class="nav-item top-level ">
						
						<a href="/changelog/">Change Log</a>
					</li>
				</ul>
			</nav>
		</header>

		<section class="main">
			<div class="page-header">
				<!-- <h2>文王之殇 --前端加油站</h2> -->
				<h3>Search</h3>
			</div>
			<article class="content">
				<p><span id="search-process">Loading</span> results <span id="search-query-container" style="display: none;">for "<strong id="search-query"></strong>"</span></p>
<ul id="search-results"></ul>

<script>
	window.data = {
		
			
				
					
					

					"a-css-box": {
						"id": "a-css-box",
						"title": "盒模型",
						"category": "",
						"url": " /A_Css/box/",
						"content": "盒模型 一、盒模型的构成"
					}

					
				
			
		
			
				
					,
					

					"a-css-vetically": {
						"id": "a-css-vetically",
						"title": "垂直居中",
						"category": "",
						"url": " /A_Css/vetically/",
						"content": "垂直居中是CSS经常需要实现的功能 一、已知长宽的的垂直居中 二、未知长宽的的垂直居中"
					}

					
				
			
		
			
				
					,
					

					"b-js-amd-cmd": {
						"id": "b-js-amd-cmd",
						"title": "AMD、CMD、Common.js和ES6的异同",
						"category": "",
						"url": " /B_Js/AMD_CMD/",
						"content": "AMD CMD Common.js 和ES6的异同 一、同步加载 common.js 主要是同步加载，主要应用于Node.js 环境 commonJS用同步的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。 二、异步加载 1、AMD 和require.js a、多个JS文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器。 b、JS加载的时候，浏览器会停止渲染页面，加载文件越多，浏览器失去响应时间越长。 AMD规范采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。这里介绍用require.js实现AMD规范的模块化：用require.config()指定引用路径等，用define()定义模块，用require()加载模块。 2、CMD 和 sea.js CMD是另一种js模块化方案，它与AMD很类似，不同点在于：AMD 推崇依赖前置、提前执行，CMD推崇依赖就近、延迟执行。此规范其实是在sea.js推广过程中产生的。 3、ES6 MODULE ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。其模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能 使用import命令的时候，用户需要知道所要加载的变量名或函数名。其实ES6还提供了export default命令，为模块指定默认输出，对应的import语句不需要使用大括号。这也更趋近于ADM的引用写法。 三、 ES6 模块与 CommonJS 模块的差异 CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。 CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。 ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。 2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。 运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。 编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。 总结：CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。"
					}

					
				
			
		
			
				
					,
					

					"b-js-es6-export": {
						"id": "b-js-es6-export",
						"title": "export、export default 和 module.export的异同",
						"category": "",
						"url": " /B_Js/es6_export/",
						"content": "export、export default 和 module.export的异同"
					}

					
				
			
		
			
				
					,
					

					"b-js-js-curry": {
						"id": "b-js-js-curry",
						"title": "函数柯里化",
						"category": "",
						"url": " /B_Js/js_curry/",
						"content": "export、export default 和 module.export的异同"
					}

					
				
			
		
			
				
					,
					

					"b-js-js-eventloop": {
						"id": "b-js-js-eventloop",
						"title": "js 事件执行机制",
						"category": "",
						"url": " /B_Js/js_eventloop/",
						"content": ""
					}

					
				
			
		
			
				
					,
					

					"c-vue-vue-1": {
						"id": "c-vue-vue-1",
						"title": "Vue2 迁移到 Vue3 都有哪些变化",
						"category": "",
						"url": " /C_Vue/vue_1/",
						"content": "根据Vue 的一整套方案 我们来逐步分析下 Vue 先简单聊一下比较重大且根本性的变化—但是对于开发影响不是很大的变化 一、proxy 二、typescript 替换 flow 三、 diff 算法的改变 对开发相对来说比较大的已有的 影响大且之前没有的 —- composition API 描述在Mixin中的一段话 在 Vue 2 中，mixin 是将部分组件逻辑抽象成可重用块的主要工具。但是，他们有几个问题： Mixin 很容易发生冲突：因为每个 mixin 的 property 都被合并到同一个组件中，所以为了避免 property 名冲突，你仍然需要了解其他每个特性。 可重用性是有限的：我们不能向 mixin 传递任何参数来改变它的逻辑，这降低了它们在抽象逻辑方面的灵活性。 为了解决这些问题，我们添加了一种通过逻辑关注点组织代码的新方法：组合式 API。 非兼容的变更 新特性 这里主要强调一下， 单文件组合式API 语法糖，这个特性目前在实验阶段，但是用起来确实很舒适。 Teleport 事件机制 原有事件机制改变 在 Vue 3 中，已经不可能使用这些 API 从组件内部监听组件自己发出的事件了，该用例暂没有迁移的方法。 生命周期变动 但是该 eventHub 模式可以被替换为实现了事件触发器接口的外部库，例如 mitt 或 tiny-emitter。 2.X 语法 2.x 版本中在一个元素上同时使用 v-if 和 v-for 时，v-for 会优先作用。 3.X 语法 3.x 版本中 v-if 总是优先于 v-for 生效。 监听数组的变化 当使用 watch 选项侦听数组时，只有在数组被替换时才会触发回调。换句话说，在数组改变时 watch 回调将不再被触发。要想在数组改变时触发 watch 回调，必须指定 deep 选项。 响应性基础 API setup 生命周期对照 首先需要了解的是响应式API对应的生命周期钩子 setup 的生命周期跟 Vue 的生命周期 会有差异。如 1.setup 的钩子函数 写几次就执行几次。 2、Vue 的钩子函数是无论写几次。只执行最后一次。 mounted(){ console.log('mo') }, mounted(){ console.log('mo1') }, updated(){ console.log('up') }, updated(){ console.log('up2') } 打印结果 unmounted! HelloWorld.vue:27 mounted! HelloWorld.vue:30 mounted2! HelloWorld.vue:65 mo1 ！！！创建自定义组件实例的时候，propsData 改变 ！！！自定义组件时，插槽统一了 watchEffect 函数式组件 Vuex Vue-Router 参考： Vue 迁移指南 Vuex 迁移指南 Vue-router Vue Cli"
					}

					
				
			
		
			
				
					,
					

					"c-vue-vue-2": {
						"id": "c-vue-vue-2",
						"title": "Vue3 源码 (3.2)",
						"category": "",
						"url": " /C_Vue/vue_2/",
						"content": "学习地址 compiler-core compiler-dom compiler-sfc compiler-ssr reactivity runtime-core runtime-dom runtime-test server-renderer sfc-playground shared size-check template-explorer vue global.d.ts"
					}

					
				
			
		
			
				
					,
					

					"d-vite-vite-1": {
						"id": "d-vite-vite-1",
						"title": "Vite 基础",
						"category": "",
						"url": " /D_Vite/vite_1/",
						"content": "Vite 的构建原理 1、在说Vite 之前我觉得有必要先介绍下webpack的由来。 早期 Webpack 刚出来的时候，是为了解决低版本浏览器不支持 ESM 模块化的问题，将各个分散的 JavaScript 模块合并成一个文件，同时将多个 JavaScript 脚本文件合并成一个文件，减少 HTTP 请求的数量，有助于提升页面首次访问的速度。后期 Webpack 乘胜追击，引入了 Loader、Plugin 机制，提供了各种构建相关的能力（babel转义、css合并、代码压缩），取代了同期的 Browserify、Gulp。 Webpack 解决了什么问题 看完估计大部分人的想法是 ，，，fuck ！！！，搞了那么久的webpack原来只是一个解决问题的临时方案。现在是否要回归正途呢。es module 在浏览器端已经成熟了。孩子养大了。（老版本 ie11及一下不支持） ![image-20210630114855509]( Users jacklin Library Application Support typora-user-images image-20210630114855509.png) Vite 以 原生 ESM 方式提供源码。这实际上是让浏览器接管了打包程序的部分工作：Vite 只需要在浏览器请求源码时进行转换并按需提供源码。根据情景动态导入代码，即只在当前屏幕上实际使用时才会被处理。 第一次构建的时候，会有一个文件缓存 Vite 会将预构建的依赖缓存到 node_modules .vite。它根据几个源来决定是否需要重新运行预构建步骤: package.json 中的 dependencies 列表 包管理器的 lockfile，例如 package-lock.json, yarn.lock，或者 pnpm-lock.yaml 可能在 vite.config.js 相关字段中配置过的 只有在上述其中一项发生更改时，才需要重新运行预构建。 如果出于某些原因，你想要强制 Vite 重新构建依赖，你可以用 –force 命令行选项启动开发服务器，或者手动删除 node_modules .vite 目录。 jacklin@192 vu3_vite % npm run dev @0.0.0 dev Users jacklin shimao_jack my vu3_vite vite Pre-bundling dependencies: vue @vue runtime-core vue-router (this will be run only when your dependencies or config have changed) vite v2.3.8 dev server running at: &gt; Local: http: localhost:3000 &gt; Network: use `--host` to expose ready in 441ms. [@vue compiler-sfc] [@vue compiler-sfc] When using experimental features, it is recommended to pin your vue dependencies to exact versions to avoid breakage. 参考文档： Vite 官方中文文档"
					}

					
				
			
		
			
				
					,
					

					"d-vite-vite-2": {
						"id": "d-vite-vite-2",
						"title": "Vite 的构建工具",
						"category": "",
						"url": " /D_Vite/vite_2/",
						"content": "Rollup 和webpack的异同 参考文档： Rollup 官方中文文档 一文带你快速上手Rollup"
					}

					
				
			
		
			
				
					,
					

					"d-webpack-webpack-1": {
						"id": "d-webpack-webpack-1",
						"title": "Webpack 基础和进阶",
						"category": "",
						"url": " /D_Webpack/webpack_1/",
						"content": "Webpack 基础 一、概念 二、主要作用及功能 Webpack 进阶 一、loader 二、plugin 三、优化和实用"
					}

					
				
			
		
			
				
					,
					

					"d-webpack-webpack-2": {
						"id": "d-webpack-webpack-2",
						"title": "Webpack 和 Vite 的比较",
						"category": "",
						"url": " /D_Webpack/webpack_2/",
						"content": "webpack和vite的异同 一、"
					}

					
				
			
		
			
				
					,
					

					"d-webpack-webpack-3": {
						"id": "d-webpack-webpack-3",
						"title": "前端如何利用Webpack进行代码分析和优化",
						"category": "",
						"url": " /D_Webpack/webpack_3/",
						"content": "一、1. 执行以下命令安装 npm install webpack-bundle-analyzer –save-dev vue.config.js 配置 chainWebpack: config =&gt; { 查看打包文件体积大小 config .plugin('webpack-bundle-analyzer') .use(require('webpack-bundle-analyzer').BundleAnalyzerPlugin) } 在package.json文件中 在 build 后面加上一个 –report “build”: “vue-cli-service build –report” 优化的方向和思想 1、查看完代码分析，我们大概知道了。打包文件的大小是否合理。 运行打包后，我们打开http: 127.0.0.1:8888之后 就会看到一个可视化的 文件占比"
					}

					
				
			
		
			
				
					,
					

					"e-node-node-1": {
						"id": "e-node-node-1",
						"title": "Express的基础",
						"category": "",
						"url": " /E_Node/node_1/",
						"content": "一、"
					}

					
				
			
		
			
				
					,
					

					"e-node-node-2": {
						"id": "e-node-node-2",
						"title": "Koa 基础",
						"category": "",
						"url": " /E_Node/node_2/",
						"content": "洋葱模型"
					}

					
				
			
		
			
				
					,
					

					"f-miniprogram-min-2": {
						"id": "f-miniprogram-min-2",
						"title": "小程序开发步骤讲解",
						"category": "",
						"url": " /F_MiniProgram/min_2/",
						"content": "一、自开发小程序 二、第三方服务商代开发 1、有管理后台 2、无管理后台"
					}

					
				
			
		
			
				
					,
					

					"f-miniprogram-mini-1": {
						"id": "f-miniprogram-mini-1",
						"title": "小程序渲染机制 --- 以微信小程序为例",
						"category": "",
						"url": " /F_MiniProgram/mini_1/",
						"content": ""
					}

					
				
			
		
			
				
					,
					

					"g-angular-angular-1": {
						"id": "g-angular-angular-1",
						"title": "浅析angular",
						"category": "",
						"url": " /G_Angular/angular_1/",
						"content": "angular"
					}

					
				
			
		
			
				
					,
					

					"k-react-react-1": {
						"id": "k-react-react-1",
						"title": "React基础",
						"category": "",
						"url": " /K_React/react_1/",
						"content": "React"
					}

					
				
			
		
			
				
					,
					

					"l-basic-web-1": {
						"id": "l-basic-web-1",
						"title": "浏览器的渲染机制",
						"category": "",
						"url": " /L_Basic/web_1/",
						"content": "浏览器的内核是指支持浏览器运行的最核心的程序，分为两个部分的，一是渲染引擎，另一个是JS引擎。渲染引擎在不同的浏览器中也不是都相同的。目前市面上常见的浏览器内核可以分为这四种：Trident（IE）、Gecko（火狐）、Blink（Chrome、Opera）、Webkit（Safari）。 浏览器从输入url开始 这里只做简述，如想详细了解可以参考我另一篇文章 要点如下： 浏览器根据 DNS 服务器得到域名的 IP 地址 向这个 IP 的机器发送 HTTP 请求 服务器收到、处理并返回 HTTP 请求 浏览器得到返回内容 这里重点讲述 浏览器返回之后的内容 其实就是一堆 HMTL 格式的字符串，因为只有 HTML 格式浏览器才能正确解析，这是 W3C 标准的要求。接下来就是浏览器的渲染过程。 一、浏览器会解析三个东西： 一是HTML SVG XHTML，HTML字符串描述了一个页面的结构，浏览器会把HTML结构字符串解析转换DOM树形结构 二是CSS，解析CSS会产生CSS规则树，它和DOM结构比较像。 三是Javascript脚本，等到Javascript 脚本文件加载后， 通过 DOM API 和 CSSOM API 来操作 DOM Tree 和 CSS Rule Tree。 二、解析完成后，浏览器引擎会通过DOM Tree 和 CSS Rule Tree 来构造 Rendering Tree。 Rendering Tree 渲染树并不等同于DOM树，渲染树只会包括需要显示的节点和这些节点的样式信息。 CSS 的 Rule Tree主要是为了完成匹配并把CSS Rule附加上Rendering Tree上的每个Element（也就是每个Frame）。 然后，计算每个Frame 的位置，这又叫layout和reflow过程 三、最后通过调用操作系统Native GUI的API绘制 二、 构建DOM 浏览器会遵守一套步骤将HTML 文件转换为 DOM 树。宏观上，可以分为几个步骤： 三、构建CSSOM 阻塞渲染的 CSS 默认情况下，CSS 被视为阻塞渲染的资源（但不阻塞html的解析），这意味着浏览器将不会渲染任何已处理的内容，直至 CSSOM 构建完毕。请务必精简CSS，尽快提供它，并利用媒体类型和查询来解除对渲染的阻塞，以缩短首屏的时间。 在渲染树构建中，要求同时具有 DOM 和 CSSOM 才能构建渲染树。这会给性能造成严重影响：HTML 和 CSS 都是阻塞渲染的资源。 HTML 显然是必需的，因为如果没有 DOM，就没有可渲染的内容，但 CSS 的必要性可能就不太明显。如果在 CSS 不阻塞渲染的情况下尝试渲染一个普通网页会怎样？ 默认情况下，CSS 被视为阻塞渲染的资源。 我们可以通过媒体类型和媒体查询将一些 CSS 资源标记为不阻塞渲染。 浏览器会下载所有 CSS 资源，无论阻塞还是不阻塞。 没有 CSS 的网页实际上无法使用。所以浏览器将阻塞渲染，直至 DOM 和 CSSOM 全都准备就绪。 CSS 是阻塞渲染的资源。需要将它尽早、尽快地下载到客户端，以便缩短首次渲染的时间。 如果有一些 CSS 样式只在特定条件下（例如显示网页或将网页投影到大型显示器上时）使用，又该如何？如果这些资源不阻塞渲染，该有多好。 可以通过 CSS“媒体类型”和“媒体查询”来解决这类情况： &lt;link href=\"style.css\" rel=\"stylesheet\"&gt; &lt;link href=\"print.css\" rel=\"stylesheet\" media=\"print\"&gt; &lt;link href=\"other.css\" rel=\"stylesheet\" media=\"(min-width: 40em)\"&gt; 媒体查询由媒体类型以及零个或多个检查特定媒体特征状况的表达式组成。例如，第一个样式表声明未提供任何媒体类型或查询，因此它适用于所有情况。也就是说它始终会阻塞渲染。第二个样式表则不然，它只在打印内容时适用---或许您想重新安排布局、更改字体等等，因此在网页首次加载时，该样式表不需要阻塞渲染。最后一个样式表声明提供了由浏览器执行的“媒体查询”：符合条件时，样式表会生效，浏览器将阻塞渲染，直至样式表下载并处理完毕。 通过使用媒体查询，我们可以根据特定用例（比如显示或打印），也可以根据动态情况（比如屏幕方向变化、尺寸调整事件等）定制外观。声明样式表时，请密切注意媒体类型和查询，因为它们将严重影响关键渲染路径的性能。 让我们考虑下面这些实例： &lt;link href=\"style.css\" rel=\"stylesheet\"&gt; &lt;link href=\"style.css\" rel=\"stylesheet\" media=\"all\"&gt; &lt;link href=\"portrait.css\" rel=\"stylesheet\" media=\"orientation:portrait\"&gt; &lt;link href=\"print.css\" rel=\"stylesheet\" media=\"print\"&gt; 第一个声明阻塞渲染，适用于所有情况。 第二个声明同样阻塞渲染：“all”是默认类型，和第一个声明实际上是等效的。 第三个声明具有动态媒体查询，将在网页加载时计算。根据网页加载时设备的方向，portrait.css 可能阻塞渲染，也可能不阻塞渲染。 最后一个声明只在打印网页时应用，因此网页在浏览器中加载时，不会阻塞渲染。 最后，“阻塞渲染”仅是指浏览器是否需要暂停网页的首次渲染，直至该资源准备就绪。无论媒寻是否命中，浏览器都会下载上述所有的CSS样式表，只不过不阻塞渲染的资源对当前媒体不生效罢了。 四、构建渲染树 五、布局与绘制 六、几点补充说明 性能优化策略 基于上面介绍的浏览器渲染原理，DOM 和 CSSOM 结构构建顺序，初始化可以对页面渲染做些优化，提升页面性能。 JS优化： defer属性： 用于开启新的线程下载脚本文件，并使脚本在文档解析完成后执行。 async属性： HTML5新增属性，用于异步下载脚本文件，下载完毕立即解释执行代码。 参考：https: segmentfault.com q 1010000000640869 CSS优化： 标签的 rel属性 中的属性值设置为 preload 能够让你在你的HTML页面中可以指明哪些资源是在页面加载完成后即刻需要的,最优的配置加载顺序，提高渲染性能 重绘（Paint） 和重排(Layout) 总结 浏览器工作流程：构建DOM -&gt; 构建CSSOM -&gt; 构建渲染树 -&gt; 布局 -&gt; 绘制。 CSSOM会阻塞渲染，只有当CSSOM构建完毕后才会进入下一个阶段构建渲染树。 通常情况下DOM和CSSOM是并行构建的，但是当浏览器遇到一个不带defer或async属性的script标签时，DOM构建将暂停，如果此时又恰巧浏览器尚未完成CSSOM的下载和构建，由于JavaScript可以修改CSSOM，所以需要等CSSOM构建完毕后再执行JS，最后才重新DOM构建。 浏览器在做性能测试的时候 lighthouse 以csdn 为例： 如果同时打开两个csdn 同源网站 会导致lighthouse 不能生成报告。 参考： https: juejin.cn post 6844903815758479374 https: www.cnblogs.com JerryChan31 p 9631934.html https: www.cnblogs.com kevin2chen p 6938021.html https: developer.mozilla.org zh-CN docs Web API Window DOMContentLoaded_event"
					}

					
				
			
		
			
				
					,
					

					"l-basic-web-10": {
						"id": "l-basic-web-10",
						"title": "浏览器储存（cookie、localStorage、sessionStorage和IndexDB）",
						"category": "",
						"url": " /L_Basic/web_10/",
						"content": "浏览器内存泄漏的原因 参考： https: blog.csdn.net muzidigbig article details 100169801"
					}

					
				
			
		
			
				
					,
					

					"l-basic-web-2": {
						"id": "l-basic-web-2",
						"title": "前端部署的发展历程",
						"category": "",
						"url": " /L_Basic/web_2/",
						"content": "前端一说起刀耕火种，那肯定紧随着前端工程化这一话题。随着 react vue angular，es6+，webpack，babel，typescript 以及 node 的发展，前端已经在逐渐替代过去 script 引 cdn 开发的方式了，掀起了工程化这一大浪潮。得益于工程化的发展与开源社区的良好生态，前端应用的可用性与效率得到了很大提高。 前端以前是刀耕火种，那前端应用部署在以前也是刀耕火种。那前端应用部署的发展得益于什么，随前端工程化带来的副产品？ 这只是一部分，而更重要的原因是 devops 的崛起。 为了更清晰地理解前端部署的发展史，了解部署时运维和前端（或者更广泛地说，业务开发人员）的职责划分，当每次前端部署发生改变时，可以思考两个问题 缓存，前端应用中http 的 response header 由谁来配？得益于工程化发展，可以对打包后得到带有 hash 值的文件可以做永久缓存 跨域， api 的代理配置由谁来配？在开发环境前端可以开个小服务，启用 webpack-dev-server 配置跨域，那生产环境呢 这两个问题都是前端面试时的高频问题，但话语权是否掌握在前端手里 时间来到 React 刚刚发展起来的这一年，这时已经使用 React 开发应用，使用 webpack 来打包。但是前端部署，仍是刀耕火种 本篇文章要求你有一定的 Docker，DevOps 以及前端工程化的知识储备。 刀耕火种 一台跳板机 一台生产环境服务器 一份部署脚本 前端调着他的 webpack，开心地给运维发了部署邮件并附了一份部署脚本，想着第一次不用套后端的模板，第一次前端可以独立部署。想着自己基础盘进一步扩大，前端不禁开心地笑了 运维照着着前端发过来的部署邮件，一遍又一遍地拉着代码，改着配置，写着 try_files， 配着 proxy_pass。 这时候，前端静态文件由 nginx 托管，nginx 配置文件大致长这个样子 server { listen 80; server_name shanyue.tech; location { # 避免非root路径404 try_files $uri $uri index.html; } # 解决跨域 location api { proxy_pass http: api.shanyue.tech; } # 为带 hash 值的文件配置永久缓存 location ~* \\.(?:css|js)$ { try_files $uri =404; expires 1y; add_header Cache-Control \"public\"; } location ~ ^.+\\..+$ { try_files $uri =404; } } 不过…经常有时候跑不起来 运维抱怨着前端的部署脚本没有标好 node 版本，前端嚷嚷着测试环境没问题 这个时候运维需要费很多心力放在部署上，甚至测试环境的部署上，前端也要费很多心力放在运维如何部署上。这个时候由于怕影响线上环境，上线往往选择在深夜，前端和运维身心俱疲 不过向来如此 鲁迅说，向来如此，那便对么。 这个时候，无论跨域的配置还是缓存的配置，都是运维来管理，运维不懂前端。但配置方式却是前端在提供，而前端并不熟悉 nginx 使用 docker 构建镜像 docker 的引进，很大程度地解决了部署脚本跑不了这个大BUG。dockerfile 即部署脚本，部署脚本即 dockerfile。这也很大程度缓解了前端与运维的摩擦，毕竟前端越来越靠谱了，至少部署脚本没有问题了 (笑 这时候，前端不再提供静态资源，而是提供服务，一个 http 服务 前端写的 dockerfile 大致长这个样子 FROM node:alpine # 代表生产环境 ENV PROJECT_ENV production # 许多 package 会根据此环境变量，做出不同的行为 # 另外，在 webpack 中打包也会根据此环境变量做出优化，但是 create-react-app 在打包时会写死该环境变量 ENV NODE_ENV production WORKDIR code ADD . code RUN npm install &amp;&amp; npm run build &amp;&amp; npm install -g http-server EXPOSE 80 CMD http-server . public -p 80 单单有 dockerfile 也跑不起来，另外前端也开始维护一个 docker-compose.yaml，交给运维执行命令 docker-compose up -d 启动前端应用。前端第一次写 dockerfile 与 docker-compose.yaml，在部署流程中扮演的角色越来越重要。想着自己基础盘进一步扩大，前端又不禁开心地笑了 version: \"3\" services: shici: build: . expose: - 80 运维的 nginx 配置文件大致长这个样子 server { listen 80; server_name shanyue.tech; location { proxy_pass http: static.shanyue.tech; } location api { proxy_pass http: api.shanyue.tech; } } 运维除了配置 nginx 之外，还要执行一个命令: docker-compose up -d 这时候再思考文章最前面两个问题 缓存，由于从静态文件转换为服务，缓存开始交由前端控制 (但是镜像中的 http-server 不太适合做这件事情) 跨域，跨域仍由运维在 nginx 中配置 前端可以做他应该做的事情中的一部分了，这是一件令人开心的事情 当然，前端对于 dockerfile 的改进也是一个慢慢演进的过程，那这个时候镜像有什么问题呢？ 构建镜像体积过大 构建镜像时间过长 使用多阶段构建优化镜像 这中间其实经历了不少坎坷，其中过程如何，详见我的另一篇文章: 如何使用 docker 部署前端应用。 其中主要的优化也是在上述所提到的两个方面 构建镜像体积由 1G+ 变为 10M+ 构建镜像时间由 5min+ 变为 1min (视项目复杂程度，大部分时间在构建时间与上传静态资源时间) FROM node:alpine as builder ENV PROJECT_ENV production ENV NODE_ENV production WORKDIR code ADD package.json code RUN npm install --production ADD . code # npm run uploadCdn 是把静态资源上传至 oss 上的脚本文件，将来会使用 cdn 对 oss 加速 RUN npm run build &amp;&amp; npm run uploadCdn # 选择更小体积的基础镜像 FROM nginx:alpine COPY --from=builder code public index.html code public favicon.ico usr share nginx html COPY --from=builder code public static usr share nginx html static 那它怎么做的 先 ADD package.json code, 再 npm install --production 之后 Add 所有文件。充分利用镜像缓存，减少构建时间 多阶段构建，大大减小镜像体积 另外还可以有一些小优化，如 npm cache 的基础镜像或者 npm 私有仓库，减少 npm install 时间，减小构建时间 npm install --production 只装必要的包 前端看着自己优化的 dockerfile，想着前几天还被运维吵，说什么磁盘一半的空间都被前端的镜像给占了，想着自己节省了前端镜像几个数量级的体积，为公司好像省了不少服务器的开销，想着自己的基础盘进一步扩大，又不禁开心的笑了 这时候再思考文章最前面两个问题 缓存，缓存由前端控制，缓存在oss上设置，将会使用 cdn 对 oss 加速。此时缓存由前端写脚本控制 跨域，跨域仍由运维在 nginx 中配置 CI CD 与 gitlab 此时前端成就感爆棚，运维呢？运维还在一遍一遍地上线，重复着一遍又一遍的三个动作用来部署 拉代码 docker-compose up -d 重启 nginx 运维觉得再也不能这么下去了，于是他引进了 CI: 与现有代码仓库 gitlab 配套的 gitlab ci CI，Continuous Integration，持续集成 CD，Continuous Delivery，持续交付 重要的不是 CI CD 是什么，重要的是现在运维不用跟着业务上线走了，不需要一直盯着前端部署了。这些都是 CI CD 的事情了，它被用来做自动化部署。上述提到的三件事交给了 CI CD .gitlab-ci.yml 是 gitlab 的 CI 配置文件，它大概长这个样子 deploy: stage: deploy only: - master script: - docker-compose up --build -d tags: - shell CI CD 不仅仅更解放了业务项目的部署，也在交付之前大大加强了业务代码的质量，它可以用来 lint，test，package 安全检查，甚至多特性多环境部署，我将会在我以后的文章写这部分事情 我的一个服务器渲染项目 shfshanyue shici 以前在我的服务器中就是以 docker docker-compose gitlab-ci 的方式部署，有兴趣的可以看看它的配置文件 shfshanyue shici:Dockerfile shfshanyue shici:docker-compose.yml shfshanyue shici:gitlab-ci.yml 如果你有个人服务器的话，也建议你做一个自己感兴趣的前端应用和配套的后端接口服务，并且配套 CI CD 把它部署在自己的自己服务器上 而你如果希望结合 github 做 CI CD，那可以试一试 github + github action 另外，也可以试试 drone.ci，如何部署可以参考我以前的文章: github 上持续集成方案 drone 的简介及部署 使用 kubernetes 部署 随着业务越来越大，镜像越来越多，docker-compose 已经不太能应付，kubernetes 应时而出。这时服务器也从1台变成了多台，多台服务器就会有分布式问题 一门新技术的出现，在解决以前问题的同时也会引进复杂性。 k8s 部署的好处很明显: 健康检查，滚动升级，弹性扩容，快速回滚，资源限制，完善的监控等等 那现在遇到的新问题是什么？ 构建镜像的服务器，提供容器服务的服务器，做持续集成的服务器是一台！ 需要一个私有的镜像仓库，这是运维的事情，harbor 很快就被运维搭建好了，但是对于前端部署来说，复杂性又提高了 先来看看以前的流程: 前端配置 dockerfile 与 docker-compose 生产环境服务器的 CI runner 拉代码(可以看做以前的运维)，docker-compose up -d 启动服务。然后再重启 nginx，做反向代理，对外提供服务 以前的流程有一个问题: 构建镜像的服务器，提供容器服务的服务器，做持续集成的服务器是一台！，所以需要一个私有的镜像仓库，一个能够访问 k8s 集群的持续集成服务器 流程改进之后结合 k8s 的流程如下 前端配置 dockerfile，构建镜像，推到镜像仓库 运维为前端应用配置 k8s 的资源配置文件，kubectl apply -f 时会重新拉取镜像，部署资源 运维问前端，需不需要再扩大下你的基础盘，写一写前端的 k8s 资源配置文件，并且列了几篇文章 使用 k8s 部署你的第一个应用: Pod，Deployment 与 Service 使用 k8s 为你的应用配置域名: Ingress 使用 k8s 为你的域名加上 https 前端看了看后端十几个 k8s 配置文件之后，摇摇头说算了算了 这个时候，gitlab-ci.yaml 差不多长这个样子，配置文件的权限由运维一人管理 deploy: stage: deploy only: - master script: - docker build -t harbor.shanyue.tech fe shanyue - docker push harbor.shanyue.tech fe shanyue - kubectl apply -f https: k8s-config.default.svc.cluster.local shanyue.yaml tags: - shell 这时候再思考文章最前面两个问题 缓存，缓存由前端控制 跨域，跨域仍由运维控制，在后端 k8s 资源的配置文件中控制 Ingress 使用 helm 部署 这时前端与运维已不太往来，除了偶尔新起项目需要运维帮个忙以外 但好景不长，突然有一天，前端发现自己连个环境变量都没法传！于是经常找运维修改配置文件，运维也不胜其烦 于是有了 helm，如果用一句话解释它，那它就是一个带有模板功能的 k8s 资源配置文件。作为前端，你只需要填参数。更多详细的内容可以参考我以前的文章 使用 helm 部署 k8s 资源 假如我们使用 bitnami nginx 作为 helm chart，前端可能写的配置文件长这个样子 image: registry: harbor.shanyue.tech repository: fe shanyue tag: 8a9ac0 ingress: enabled: true hosts: - name: shanyue.tech path: tls: - hosts: - shanyue.tech secretName: shanyue-tls # livenessProbe: # httpGet: # path: # port: http # initialDelaySeconds: 30 # timeoutSeconds: 5 # failureThreshold: 6 # # readinessProbe: # httpGet: # path: # port: http # initialDelaySeconds: 5 # timeoutSeconds: 3 # periodSeconds: 5 这时候再思考文章最前面两个问题 缓存，缓存由前端控制 跨域，跨域由后端控制，配置在后端 Chart 的配置文件 values.yaml 中 到了这时前端和运维的职责所在呢？ 前端需要做的事情有: 写前端构建的 dockerfile，这只是一次性的工作，而且有了参考 使用 helm 部署时指定参数 那运维要做的事情呢 提供一个供所有前端项目使用的 helm chart，甚至不用提供，如果运维比较懒那就就使用 bitnami nginx 吧。也是一次性工作 提供一个基于 helm 的工具，禁止业务过多的权限，甚至不用提供，如果运维比较懒那就直接使用 helm 这时前端可以关注于自己的业务，运维可以关注于自己的云原生，职责划分从未这般清楚 统一前端部署平台 后来运维觉得前端应用的本质是一堆静态文件，较为单一，容易统一化，来避免各个前端镜像质量的参差不齐。于是运维准备了一个统一的 node 基础镜像，做了一个前端统一部署平台，而这个平台可以做什么呢 CI CD: 当你 push 代码到仓库的特定分支会自动部署 http headers: 你可以定制资源的 http header，从而可以做缓存优化等 http redirect rewrite: 如果一个 nginx，这样可以配置 api，解决跨域问题 hostname: 你可以设置域名 CDN: 把你的静态资源推到 CDN https: 为你准备证书 Prerender: 结合 SPA，做预渲染 前端再也不需要构建镜像，上传 CDN 了，他只需要写一份配置文件就可以了，大致长这个样子 build: command: npm run build dist: dist hosts: - name: shanyue.tech path: headers: - location: * values: - cache-control: max-age=7200 - location: assets * values: - cache-control: max-age=31536000 redirects: - from : api to: https: api.shanyue.tech status: 200 此时，前端只需要写一份配置文件，就可以配置缓存，配置 proxy，做应该属于前端做的一切，而运维也再也不需要操心前端部署的事情了 前端看着自己刚刚写好的配置文件，怅然若失的样子… 不过一般只有大厂会有这么完善的前端部署平台，如果你对它有兴趣，你可以尝试下 netlify，可以参考我的文章: 使用 netlify 部署你的前端应用 服务端渲染与后端部署 大部分前端应用本质上是静态资源，剩下的少部分就是服务端渲染了，服务端渲染的本质上是一个后端服务，它的部署可以视为后端部署 后端部署的情况更为复杂，比如 配置服务，后端需要访问敏感数据，但又不能把敏感数据放在代码仓库。你可以在 environment variables， consul 或者 k8s configmap 中维护 上下链路服务，你需要依赖数据库，上游服务 访问控制，限制 IP，黑白名单 RateLimit 等等 我将在以后的文章分享如何在 k8s 中部署一个后端 小结 随着 devops 的发展，前端部署越来越简单，可控性也越来越高，建议所有人都稍微学习一下 devops 的东西。 道阻且长，行则将至。 参考：https: github.com shfshanyue blog edit master frontend-engineering deploy.md"
					}

					
				
			
		
			
				
					,
					

					"l-basic-web-3": {
						"id": "l-basic-web-3",
						"title": "浏览器缓存机制",
						"category": "",
						"url": " /L_Basic/web_3/",
						"content": "web缓存描述 ： Web 缓存是可以自动保存常见文档副本的 HTTP 设备。当 Web 请求抵达缓存时， 如果本地有“已缓存的”副本，就可以从本地存储设备而不是原始服务器中提取这 个文档。（此结论来自http权威指南） 缓存的优缺点： 优点： 缓存减少了冗余的数据传输，节省了你的网络费用。 缓存缓解了网络瓶颈的问题。不需要更多的带宽就能够更快地加载页面。 缓存降低了对原始服务器的要求。服务器可以更快地响应，避免过载的出现。 缓存降低了距离时延，因为从较远的地方加载页面会更慢一些。 缺点： 缓存中的数据可能与服务器的数据不一致； 消耗内存； 缓存验证概述： 缓存可分为强缓存和协商缓存。 1，浏览器进行资源请求时，会判断response headers是否命中强缓存，如果命中，直接从本地读取缓存，不会向服务器发送请求， 2，当强缓存没有命中时，会发送请求到服务端，判断协商缓存是否命中，如果命中，服务器将请求返回，不会返回资源，告诉浏览器从本地读取缓存。如何不命中，服务器直接返回资源 区别： 强缓存命中，不会请求服务器，直接请求缓存；协商缓存命中，会请求服务器，不会返回内容，然后读取缓存； 缓存的处理流程 from memory cache 和 from disk cache的区别 from memory cache：字面理解是从内存中，其实也是字面的含义，这个资源是直接从内存中拿到的，不会请求服务器一般已经加载过该资源且缓存在了内存当中，当关闭该页面时，此资源就被内存释放掉了，再次重新打开相同页面时不会出现from memory cache的情况 from disk cache：同上类似，此资源是从磁盘当中取出的，也是在已经在之前的某个时间加载过该资源，不会请求服务器但是此资源不会随着该页面的关闭而释放掉，因为是存在硬盘当中的，下次打开仍会from disk cache from memory cache代表使用内存中的缓存，from disk cache则代表使用的是硬盘中的缓存，浏览器读取缓存的顺序为memory –&gt; disk。 访问https: heyingye.github.io –&gt; 200 –&gt; 关闭博客的标签页 –&gt; 重新打开https: heyingye.github.io –&gt; 200(from disk cache) –&gt; 刷新 –&gt; 200(from memory cache) 我们需要了解内存缓存(from memory cache)和硬盘缓存(from disk cache)，如下: 内存缓存(from memory cache)：内存缓存具有两个特点，分别是快速读取和时效性： 快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。 时效性：一旦该进程关闭，则该进程的内存则会清空。 硬盘缓存(from disk cache)：硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。 在浏览器中，浏览器会在js和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。 以下是缓存实现的四种方式 强缓存 强缓存又分为Expires 和 Cache-Control Expires,该值是一个GMT时间格式个字符串，浏览器进行第一次请求时，服务器会在返回头部加上Expires，下次请求，如果在这个时间之前则命中缓存， app.get(‘ ’, (req, res) =&gt; { const cssContent = path.join(__dirname, '. html index.html'); fs.readFile(cssContent, function(err, data) { res.setHeader(\"Expires\", new Date(Date.now() + 2592000000).toUTCString()); res.end(data); }) }); 复制代码Cache-Control ，该值是利用max-age判断缓存的生命周期，是以秒为单位，如何在生命周期时间内，则命中缓存 app.get(‘ ’, (req, res) =&gt; { const cssContent = path.join(__dirname, ‘. html index.html’); fs.readFile(cssContent, function(err, data) { res.setHeader(“Cache-Control”, “max-age=0”); res.end(data); }) }); 复制代码命中缓存： 协商缓存 协商缓存利用Last-Modified , If-Modified-Since 和 ETag , If-None-Match来实现 Last-Modified , If-Modified-Since Last-Modified： 表示为为实体头部部分，response返回，表示为资源的最后更新时间 If-Modified-Since：通过比较两次的时间判断，资源在请求期间是否有修改，假如没有修改，则命中协商缓存，浏览器从缓存中读取资源，如果没有命中，资源有过修改，返回新的Last-Modified时间和服务器资源 app.get(‘ ’, (req, res) =&gt; { const cssContent = path.join(__dirname, ‘. html index.html’) fs.stat(cssContent, (err, start) =&gt; { if (req.headers[‘if-modified-since’] === start.mtime.toUTCString()) { res.writeHead(304, ‘Not Modified’); res.end(); } else { fs.readFile(cssContent, function (err, data) { let lastModified = start.mtime.toUTCString(); res.setHeader(‘Last-Modified’, lastModified); res.writeHead(200, ‘OK’); res.end(data); }) } }) }); 复制代码ETag , If-None-Match 有些情况下仅判断最后修改日期来验证资源是否有改动是不够的： 1，存在周期性重写某些资源，但资源实际包含的内容并无变化； 2，被修改的信息并不重要，如注释等； 3，Last-Modified无法精确到毫秒，但有些资源更新频率有时会小于一秒。 ETag:为相应头部字段，表示资源内容的唯一标识，随服务器response返回； If-None-Match: 服务器比较请求头中的If-None-Match和当前资源中的etag是否一致，来判断资源是否修改过，如果没有修改，则命中缓存，浏览器从缓存中读取资源，如果修改过，服务器会返回新的etag，并返回资源； app.get(‘ home’, (req, res) =&gt; { const cssContent = path.join(__dirname, '. html index.html') fs.stat(cssContent, (err, start) =&gt; { let etag = md5(cssContent); if (req.headers['if-none-match'] === etag) { res.writeHead(304, 'Not Modified'); res.end(); } else { fs.readFile(cssContent, function (err, data) { res.setHeader('Etag', etag); res.writeHead(200, 'OK'); res.end(data); }) } }) }); 复制代码不推荐使用 Expires 首部，它指定的是实际的过期日期而不是秒数。HTTP 设计者 后来认为，由于很多服务器的时钟都不同步，或者不正确，所以最好还是用剩余秒 数，而不是绝对时间来表示过期时间。 ETag解决了Last-Modified使用时可能出现的资源的时间戳变了但内容没变及如果再一秒钟以内资源变化但Last-Modified没变的问题，感觉ETag更加稳妥。 补充：根据浏览器缓存策略，Expire和Cache-Control用回车、后退、F5刷新会跳过本地缓存，每次都会从服务器中获数据。 参考：https: mp.weixin.qq.com s d2zeGhUptGUGJpB5xHQbOA"
					}

					
				
			
		
			
				
					,
					

					"l-basic-web-4": {
						"id": "l-basic-web-4",
						"title": "xhr 和 fetch请求方式的比较",
						"category": "",
						"url": " /L_Basic/web_4/",
						"content": "XMLHttpRequest对象 ———— xhr 类请求 现代浏览器，最开始与服务器交换数据，都是通过XMLHttpRequest对象。它可以使用JSON、XML、HTML和text文本等格式发送和接收数据。 优点： 不重新加载页面的情况下更新网页 在页面已加载后从服务器请求 接收数据 在后台向服务器发送数据。 缺点： 使用起来也比较繁琐，需要设置很多值。 早期的IE浏览器有自己的实现，这样需要写兼容代码。 ajax请求 jquery axios 封装库 fetch Fetch API提供了一个 JavaScript 接口，用于访问和操作HTTP管道的部分，例如请求和响应。它还提供了一个全局 fetch() 方法，该方法提供了一种简单，合理的方式来跨网络异步获取资源。 fetch 是底层API，代替XHR，可以轻松处理各种格式，非文本化格式。可以很容易的被其他技术使用，例如Service Workers。但是想要很好的使用fetch，需要做一些封装处理。 fetch的语法简洁，更语义化 基于promise，支持async await 同构方便，使用isomorphic-fetch Fetch的缺点： fetch只对网络错误报错，http状态码错误不报错 fetch不支持abort，无法终止 fetch不支持超时控制，使用setTimeout和Promise.reject实现的超时控制不能阻止请求过程继续在后台运行，造成了流量的浪费 fetch没有原生检测请求进度的方式，XHR可以 默认情况下fetch不发送cookie，除非手动配置 参考文档：https: developer.mozilla.org zh-CN docs Web API Fetch_API Using_Fetch"
					}

					
				
			
		
			
				
					,
					

					"l-basic-web-5": {
						"id": "l-basic-web-5",
						"title": "输入一个url发生了什么",
						"category": "",
						"url": " /L_Basic/web_5/",
						"content": "第一步"
					}

					
				
			
		
			
				
					,
					

					"l-basic-web-6": {
						"id": "l-basic-web-6",
						"title": "http 演进",
						"category": "",
						"url": " /L_Basic/web_6/",
						"content": "http 超文本传输​​协议（HTTP）是用于传输诸如HTML的超媒体文档的应用层协议。它被设计用于Web浏览器和Web服务器之间的通信，但它也可以用于其他目的。 HTTP遵循经典的客户端-服务端模型，客户端打开一个连接以发出请求，然后等待它收到服务器端响应。 HTTP是无状态协议，意味着服务器不会在两个请求之间保留任何数据（状态）。虽然通常基于TCP IP层，但可以在任何可靠的传输层上使用;也就是说，一个不会静默丢失消息的协议，如UDP。 http1.0 时代 影响一个 HTTP 网络请求的因素主要有两个：带宽和延迟。 带宽：如果说我们还停留在拨号上网的阶段，带宽可能会成为一个比较严重影响请求的问题，但是现在网络基础建设已经使得带宽得到极大的提升，我们不再会担心由带宽而影响网速，那么就只剩下延迟了。 延迟： 浏览器阻塞（HOL blocking）：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 4 个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞。 DNS 查询（DNS Lookup）：浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是 DNS。这个通常可以利用DNS缓存结果来达到减少这个时间的目的。 建立连接（Initial connection）：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。 主要区别 HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在： 缓存处理，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。 带宽优化及网络连接的使用，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。 错误通知的管理，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。 Host头处理，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。 长连接，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。 Https HTTP Strict Transport Security (通常简称为HSTS) 是一个安全功能，它告诉浏览器只能通过HTTPS访问当前资源, 禁止HTTP方式. Strict Transport Security解决了这个问题；只要你通过HTTPS请求访问银行网站，并且银行网站配置好Strict Transport Security，你的浏览器知道自动使用HTTPS请求，这可以阻止黑客的中间人攻击的把戏。 启用 Strict Transport Security 开启HSTS只需要当通过HTTPS方式访问你的网站时，返回 Strict-Transport-SecurityHTTP 头信息: Strict-Transport-Security: max-age=expireTime [; includeSubdomains] HTTPS与HTTP的一些区别 HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。 HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL TLS之上，SSL TLS运行在TCP之上，所有传输的内容都经过加密的。 HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。 使用SPDY加快你的网站速度 2012年google如一声惊雷提出了SPDY的方案，大家才开始从正面看待和解决老版本HTTP协议本身的问题，SPDY可以说是综合了HTTPS和HTTP两者有点于一体的传输协议，主要解决： 降低延迟，针对HTTP高延迟的问题，SPDY优雅的采取了多路复用（multiplexing）。多路复用通过多个请求stream共享一个tcp连接的方式，解决了HOL blocking的问题，降低了延迟同时提高了带宽的利用率。 请求优先级（request prioritization）。多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY允许给每个request设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的html内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。 header压缩。前面提到HTTP1.x的header很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。 基于HTTPS的加密协议传输，大大提高了传输数据的可靠性。 服务端推送（server push），采用了SPDY的网页，例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。SPDY构成图： SPDY位于HTTP之下，TCP和SSL之上，这样可以轻松兼容老版本的HTTP协议(将HTTP1.x的内容封装成一种新的frame格式)，同时可以使用已有的SSL功能。 HTTP2 HTTP2.0可以说是SPDY的升级版（其实原本也是基于SPDY设计的），但是，HTTP2.0 跟 SPDY 仍有不同的地方，主要是以下两点 ● HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS ● HTTP2.0 消息头的压缩算法采用 HPACK，而非 SPDY 采用的 DEFLATE http2 新特性 ● 新的二进制格式（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。 ● 多路复用（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。多路复用原理图： ●header压缩，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。 ● 服务端推送（server push），同SPDY一样，HTTP2.0也具有server push功能。目前，有大多数网站已经启用HTTP2.0，例如YouTuBe，淘宝网等网站，利用chrome控制台可以查看是否启用H2： chrome=&gt;Network=&gt;Name栏右键=&gt;√Protocol 复制代码"
					}

					
				
			
		
			
				
					,
					

					"l-basic-web-7": {
						"id": "l-basic-web-7",
						"title": "前端大厦的基石 --- AST",
						"category": "",
						"url": " /L_Basic/web_7/",
						"content": "如果你查看目前任何主流的项目中的devDependencies，会发现前些年的不计其数的插件诞生。我们归纳一下有：javascript转译、代码压缩、css预处理器、elint、pretiier，等。有很多js模块我们不会在生产环境用到，但是它们在我们的开发过程中充当着重要的角色。所有的上述工具，不管怎样，都建立在了AST这个巨人的肩膀上。 推荐在线调试工具: https: astexplorer.net 参考：https: segmentfault.com a 1190000016231512"
					}

					
				
			
		
			
				
					,
					

					"l-basic-web-8": {
						"id": "l-basic-web-8",
						"title": "浅谈前端优化的方向",
						"category": "",
						"url": " /L_Basic/web_8/",
						"content": "在谈到优化之前，我们要先了解浏览器是如何执行并渲染网页的，可以参考我另一篇 文章 网络层 浏览器层 代码层"
					}

					
				
			
		
			
				
					,
					

					"l-basic-web-9": {
						"id": "l-basic-web-9",
						"title": "浏览器内存泄漏",
						"category": "",
						"url": " /L_Basic/web_9/",
						"content": "浏览器内存泄漏的原因 参考： https: blog.csdn.net muzidigbig article details 100169801"
					}

					
				
			
		
			
				
					,
					

					"m-program-program-1": {
						"id": "m-program-program-1",
						"title": "数据可视化项目",
						"category": "",
						"url": " /M_Program/program_1/",
						"content": "一、使用echart 技术 ———— 以小牛电动车的灵感系统为例 1、项目简介 一、使用d3.js技术 ———— 以股票信息系统为例 1、项目简介"
					}

					
				
			
		
			
				
					,
					

					"m-program-program-2": {
						"id": "m-program-program-2",
						"title": "新零售会员通 -- 天猫 有赞 微信会员渠道打通项目",
						"category": "",
						"url": " /M_Program/program_2/",
						"content": "一、数据基准问题 二、会员粉丝引入问题 三、会员数据比较和合并"
					}

					
				
			
		
			
				
					,
					

					"m-program-program-3": {
						"id": "m-program-program-3",
						"title": "温顾知新",
						"category": "",
						"url": " /M_Program/program_3/",
						"content": "一、Vue3 二、jest 单元测试 element ui 3参考 系统学习测试用例 三、"
					}

					
				
			
		
			
				
					,
					

					"n-math-math-1": {
						"id": "n-math-math-1",
						"title": "动态规划",
						"category": "",
						"url": " /N_math/math_1/",
						"content": "动态规划"
					}

					
				
			
		
	};
</script>
<script src="/scripts/lunr.min.js"></script>
<script src="/scripts/search.js"></script>

			</article>
		</section>

		<script>
			document.getElementById("open-nav").addEventListener("click", function () {
				document.body.classList.toggle("nav-open");
			});
			document.getElementById("backtop").addEventListener("click", function () {
				document.body.scrollTop = 0;
    		document.documentElement.scrollTop = 0;
			});

		</script>
	</body>
</html>
